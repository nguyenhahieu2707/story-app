package com.hiendao.domain.mockData

import androidx.room.withTransaction
import com.hiendao.data.local.dao.ChapterBodyDao
import com.hiendao.data.local.dao.ChapterDao
import com.hiendao.data.local.dao.LibraryDao
import com.hiendao.data.local.database.AppDatabase
import com.hiendao.data.local.entity.BookEntity
import com.hiendao.data.local.entity.ChapterEntity
import com.hiendao.data.local.entity.ChapterBodyEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlin.text.StringBuilder

object MockData {
    fun generateMockData(bookCount: Int = 3, chaptersPerBook: Int = 10): Triple<List<BookEntity>, List<ChapterEntity>, List<ChapterBodyEntity>> {
        val books = mutableListOf<BookEntity>()
        val chapters = mutableListOf<ChapterEntity>()
        val bodies = mutableListOf<ChapterBodyEntity>()
        val now = System.currentTimeMillis()
        for (i in 1..bookCount) {
            val bookId = "book_$i"
            books += BookEntity(
                title = "Mock Book #$i",
                id = bookId,
                completed = false,
                lastReadChapter = null,
                inLibrary = true,
                coverImageUrl = "",
                description = "Auto-generated mock description for book $i.",
                lastReadEpochTimeMilli = now,
                author = "Author $i",
            )
            for (j in 1..chaptersPerBook) {
                val chapId = "${bookId}_ch_$j"
                chapters += ChapterEntity(
                    title = "Chapter $j",
                    id = chapId,
                    bookId = bookId,
                    position = j - 1,
                    read = false,
                    lastReadPosition = 0,
                    lastReadOffset = 0
                )
                bodies += ChapterBodyEntity(
                    chapterId = chapId,
                    body = "Mock body for $chapId.\nThis is autogenerated content for testing."
                )
            }
        }
        return Triple(books, chapters, bodies)
    }

    fun generateSqlInserts(
        books: List<BookEntity>,
        chapters: List<ChapterEntity>,
        bodies: List<ChapterBodyEntity>
    ): String {
        fun esc(s: String?): String = when {
            s == null -> "NULL"
            else -> "'${s.replace("'", "''")}'"
        }
        val sb = StringBuilder()
        for (b in books) {
            sb.append("INSERT INTO BookEntity (title, id, completed, lastReadChapter, inLibrary, coverImageUrl, description, isFavourite, lastReadEpochTimeMilli, author) VALUES (")
                .append(esc(b.title)).append(",")
                .append(esc(b.id)).append(",")
                .append(if (b.completed) "1" else "0").append(",")
                .append(esc(b.lastReadChapter)).append(",")
                .append(if (b.inLibrary) "1" else "0").append(",")
                .append(esc(b.coverImageUrl)).append(",")
                .append(esc(b.description)).append(",")
                .append(if(b.isFavourite) "1" else "0").append(",")
                .append(b.lastReadEpochTimeMilli).append(",")
                .append(esc(b.author))
                .append(");\n")
        }
        for (c in chapters) {
            sb.append("INSERT INTO ChapterEntity (title, id, bookId, position, read, lastReadPosition, lastReadOffset) VALUES (")
                .append(esc(c.title)).append(",")
                .append(esc(c.id)).append(",")
                .append(esc(c.bookId)).append(",")
                .append(c.position).append(",")
                .append(if (c.read) "1" else "0").append(",")
                .append(c.lastReadPosition).append(",")
                .append(c.lastReadOffset)
                .append(");\n")
        }
        for (bd in bodies) {
            sb.append("INSERT INTO ChapterBodyEntity (chapterId, body) VALUES (")
                .append(esc(bd.chapterId)).append(",")
                .append(esc(bd.body))
                .append(");\n")
        }
        return sb.toString()
    }

    suspend fun insertMocksWithDaos(
        appDatabase: AppDatabase,
        libraryDao: LibraryDao,
        chapterDao: ChapterDao,
        chapterBodyDao: ChapterBodyDao,
        bookCount: Int = 3,
        chaptersPerBook: Int = 10
    ) {
        val (books, chapters, bodies) = MockData.generateMockData(bookCount, chaptersPerBook)
        // Run in Room transaction
        appDatabase.withTransaction {
            // Use your DAO insert methods; adjust names if necessary
            libraryDao.insertReplace(books)          // or libraryDao.insert(books)
            chapterDao.insert(chapters)          // implement insertAll in ChapterDao if absent
            chapterBodyDao.insertReplace(bodies)        // implement insertAll in ChapterBodyDao if absent
        }
    }

    suspend fun insertMocksWithSql(
        appDatabase: AppDatabase,
        bookCount: Int = 3,
        chaptersPerBook: Int = 10
    ) = withContext(Dispatchers.IO) {
        val (books, chapters, bodies) = MockData.generateMockData(bookCount, chaptersPerBook)
        val sql = MockData.generateSqlInserts(books, chapters, bodies)
        val db = appDatabase.openHelper.writableDatabase
        db.beginTransaction()
        try {
            // execute each statement (sql contains trailing `;` + newline per statement)
            sql.split(";\n").map { it.trim() }.filter { it.isNotEmpty() }.forEach { stmt ->
                db.execSQL("$stmt;")
            }
            db.setTransactionSuccessful()
        } finally {
            db.endTransaction()
        }
    }
}